// Created by Ivan June 2017
module.exports = (function() {
  "use strict";
  const EventEmitter = require("events").EventEmitter;
  const Promise = require("bluebird");
  const SerialPort = require("serialport");
  const _ = require("lodash");
  const output = require("nqm-databot-utils").output;
  const oemDeviceConfig = require("./device-config.json");

  const delimiter = "\r\n";

  class OEMDriver extends EventEmitter {
    /**
     * Constructor for OEMDriver
     * @param {object} config - Configuration parameters
     */
    constructor(config) {
      super();
      this.config = config;
      this.cachedData = {};

      this.serialPort = new SerialPort(
        this.config.port,
        {
          autoOpen: false,
          baudRate: 38400,
          parser: SerialPort.parsers.readline(delimiter),
        }
      );
    }

    /**
     * Promise wrapper for serialport's close method
     */
    closePort() {
      output.debug("closing port");
      return new Promise((resolve, reject) => {
        this.serialPort.close((err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }

    /**
     * Parses data from serial port generated by OEM device
     * @param {string} data - String written to serial port by OEM device 
     */
    onDataReceived(data) {
      const split = data.split(" ");
      if (split.length < 2 || (split[0] !== "OK" && split[0] !== "")) {
        output.debug(`OEM - ignoring frame: ${data}`);
      } else {
        const nodeId = parseInt(split[1], 10);
        const monitoredDevice = _.find(this.config.sensors, (device) => device.nodeId === nodeId);
        if (monitoredDevice) {
          if (oemDeviceConfig[monitoredDevice.type]) {
            const deviceConfig = oemDeviceConfig[monitoredDevice.type];
            const logObj = {};
            let dataIndex = 2;
            _.each(deviceConfig, (config) => {
              if (monitoredDevice.log[config.name]) {
                const dataItem = ((parseInt(split[dataIndex], 10) + parseInt(split[dataIndex + 1], 10) * 256) * config.scale).toFixed(1);
                logObj[config.name] = parseFloat(dataItem, 10);
              }
              dataIndex += 2;
            });
            if (_.isEqual(logObj, this.cachedData[nodeId])) {
              output.debug(`OEM - data not changed for node ${nodeId}`);
            } else {
              logObj.timestamp = Date.now();
              this.emit("data", monitoredDevice.feedId, logObj);
              this.cachedData[nodeId] = logObj;
            }
          } else {
            output.debug(`OEM - no configuration for device type ${monitoredDevice.type}`);
          }
        } else {
          output.debug(`OEM ignoring data for node ${nodeId}`);
        }
      }
    }

    /**
     * Promise wrapper for serialport's open port method
     * This may require elevated privileges
     */
    openPort() {
      output.debug("opening port");
      return new Promise((resolve, reject) => {
        this.serialPort.open((err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }

    /**
     * Handles initialisation
     */
    start() {
      return this.openPort()
      .then(() => {
        output.debug("OEM - opene port");

        this.serialPort.on("error", (err) => {
          output.debug(`OEM - port error - ${err.message}`);
        });

        this.serialPort.on("data", (data) => {
          if (typeof data !== "undefined" && data !== null) {
            this.onDataReceived(data);
          }
        });
      })
      .delay(1000)
      .then(() => {
        this.serialPort.write("4b");
      })
      .delay(500)
      .then(() => {
        this.serialPort.write(`${this.config.oemNetwork}g`);
      })
      .delay(500)
      .then(() => {
        this.serialPort.write("1i");
        return Promise.resolve();
      })
      .catch((err) => {
        return Promise.reject(new Error(`OEM - failed to open port ${err.message}`));
      });
    }

    /**
     * Disconnects from serial port and stops polling
     */
    stop() {
      if (this.serialPort !== null) {
        return this.closePort()
        .then(() => {
          this.serialPort = null;
          return Promise.resolve();
        })
        .catch((err) => {
          return Promise.reject(`OEM - failed closing port - ${err.message}`);
        });
      } else {
        return Promise.resolve();
      }
    }
  }

  return OEMDriver;
}());
